package gogen2

import (
	"fmt"
	"go/ast"
)

type GogenInterfaceBuilder struct {
	GogenBuilder
	unknownInterface map[FieldType]ast.Expr
}

func NewGogenInterfaceBuilder(goModPath, path string) *GogenInterfaceBuilder {
	return &GogenInterfaceBuilder{
		unknownInterface: map[FieldType]ast.Expr{},
		GogenBuilder: GogenBuilder{
			path:          path,
			goModPath:     goModPath,
			importMap:     map[Expression]GogenImport{},
			usedImport:    map[Expression]GogenImport{},
			mapOfRequire:  map[RequirePath]CompletePath{},
			expressionMap: map[Expression][]string{},
			typeMap:       map[FieldType]ast.Expr{},
			unknownTypes:  map[FieldName]*GogenField{},
		},
	}
}

func (gsb *GogenInterfaceBuilder) Build(interfaceName string) (*GogenInterface, error) {

	gc := NewGogenInterface(interfaceName)

	// trace the primary interface
	err := gsb.traceType(gsb.path, gc.Name, gsb.handleInterfaceTarget(gc))
	if err != nil {
		return nil, err
	}

	for {

		for ft, _ := range gsb.unknownInterface {

			tm, exist := gsb.typeMap[ft]
			if !exist {
				return nil, fmt.Errorf("not exist %v in typeMap", ft)
			}

			interfaceType, ok := tm.(*ast.InterfaceType)
			if !ok {
				return nil, fmt.Errorf("not ok %v", tm)
			}

			err = gsb.handleMethodInterface(ft, interfaceType, gc)
			if err != nil {
				return nil, err
			}

			delete(gsb.unknownInterface, ft)
		}

		if len(gsb.unknownInterface) == 0 {
			break
		}
	}

	for _, gf := range gsb.unknownTypes {

		switch dataTypeExpr := gf.DataType.Expr.(type) {

		case *ast.SelectorExpr:
			theEx := Expression(dataTypeExpr.X.(*ast.Ident).String())
			gi, exist := gsb.importMap[theEx]
			if !exist {
				return nil, fmt.Errorf("%s is not exist in importmap", theEx)
			}

			ft := FieldType(dataTypeExpr.Sel.String())
			err = gsb.traceType(string(gi.CompletePath), ft, func(fieldType FieldType, expr ast.Expr) error {
				gsb.typeMap[fieldType] = expr
				return nil
			})
			if err != nil {
				return nil, err
			}

			ts, exist := gsb.typeMap[ft]
			if !exist {
				logDebug("dataType %v tidak ditemukan?", gf.DataType.Type)
				continue
			}

			gf.handleDefaultValue(ts)

		}

	}

	return gc, nil
}

func (gsb *GogenInterfaceBuilder) handleInterfaceTarget(gc *GogenInterface) func(fieldType FieldType, expr ast.Expr) error {

	return func(fieldType FieldType, expr ast.Expr) error {

		switch ts := expr.(type) {
		case *ast.InterfaceType:
			logDebug("bertemu interface target %s !! langsung kita olah MethodInterfacenya", fieldType)
			logDebug("start  handleMethodInterface")
			err := gsb.handleMethodInterface(fieldType, ts, gc)
			if err != nil {
				return err
			}
			logDebug("finish handleMethodInterface")

		case *ast.StructType:
			logDebug("target adalah struct")
			gsb.typeMap[fieldType] = ts

		default:
			return fmt.Errorf("unsupported type %T", ts)
		}

		return nil
	}
}

func (gsb *GogenInterfaceBuilder) handleMethodInterface(typeSpecName FieldType, interfaceType *ast.InterfaceType, gc *GogenInterface) error {

	for _, method := range interfaceType.Methods.List {

		switch methodType := method.Type.(type) {

		case *ast.FuncType:
			logDebug("masuk sebagai inline func")

			// harus ada nama kalau tidak ini tidak normal
			if method.Names == nil && len(method.Names) > 0 {
				return fmt.Errorf("method must have name")
			}
			methodName := method.Names[0].String()

			// nama methodnya harus public
			if !IsExported(methodName) {
				continue
			}

			// ini adalah tujuan akhir dari method ini
			gm := NewGogenMethod(typeSpecName, MethodName(methodName))
			gc.Methods = append(gc.Methods, gm)

			// karena sudah ketemu, jadi kita remove dari unknown interface
			//delete(gsb.unknownInterface, typeSpecName)

			logDebug("start  handleFuncParamResultType")
			gsb.handleFuncParamResultType(methodType, gm)
			logDebug("finish handleFuncParamResultType")

		case *ast.Ident:
			logDebug("masuk sebagai ident %v", methodType.String())

			// tidak mungkin ada import disini
			// disini kita berharap ident yg ditemukan sudah pernah didaftarkan pada typeMap
			// dan ident disini sudah pasti adalah sebuah interface
			im, exist := gsb.typeMap[FieldType(methodType.String())]
			if !exist {
				// jika masuk disini, maka ident belum pernah ditemukan, tapi mgk nanti akan ketemu
				// mungkin ada di package yg sama dan file yg sama (setelah interface target),
				// mungkin ada di package yg sama namun file yg berbeda
				// dan tidak mungkin ada di package yang berbeda
				// kita belum tahu methodType itu apa, masukin aj dulu nanti akan kita cek.
				gsb.unknownInterface[FieldType(methodType.String())] = methodType
				continue
			}

			// jika masuk kesini, maka ident ini sudah pasti sebuah interface yang sudah pernah ditemukan diawal
			// tapi belum pernah ditelusuri lebih lanjut
			// kita akan selesaikan dengan dirinya sendiri sebagai interfaceType (recursive)
			err := gsb.handleMethodInterface(FieldType(methodType.String()), im.(*ast.InterfaceType), gc)
			if err != nil {
				return err
			}

		case *ast.SelectorExpr:
			logDebug("masuk sebagai selector")

			// kalau masuk sini sudah pasti belum pernah ditemukan dalam interfaceType
			// sudah pasti ada import yang akan kita pakai disini
			for _, expr := range gsb.extractAllExpression(methodType) {
				importFromMap, exist := gsb.importMap[expr]
				if !exist {
					return fmt.Errorf("aneh ketemu selector tapi tidak ada di import")
				}
				gsb.usedImport[expr] = importFromMap
			}

			// dapatkan namanya
			//m := fmt.Sprintf("%v.%v", methodType.X.(*ast.Ident).String(), methodType.Sel.String())
			m := methodType.Sel.String()
			logDebug("nama selectornya %v", m)

			theEx := Expression(methodType.X.(*ast.Ident).String())
			gi, exist := gsb.importMap[theEx]
			if !exist {
				return fmt.Errorf("%s is not exist in importmap", theEx)
			}

			err := gsb.traceType(string(gi.CompletePath), FieldType(methodType.Sel.String()), gsb.handleInterfaceTarget(gc))
			if err != nil {
				return err
			}

			// sudah pasti ada di package yg berbeda yang akan kita telusuri nanti
			// method Type disini sudah pasti selector,
			// tapi kita belum tahu Selectornya type apa, masukin aj dulu nanti akan kita cek.
			//gsb.unknownInterface[FieldType(m)] = methodType

		default:
			return fmt.Errorf("unsupported type %v", methodType)

		}

	}

	return nil
}

func (gsb *GogenInterfaceBuilder) handleFuncParamResultType(methodType *ast.FuncType, gm *GogenMethod) {

	if methodType.Params.NumFields() > 0 {
		for _, param := range methodType.Params.List {

			for _, s := range gsb.extractAllExpression(param.Type) {
				importFromMap, exist := gsb.importMap[s]
				if exist {
					gsb.usedImport[s] = importFromMap
				}
			}

			if param.Names != nil {

				for _, n := range param.Names {
					gf := NewGogenField(FieldName(n.String()), param.Type)
					gm.Params = append(gm.Params, gf)
					gsb.checkDefaultValue(gf)
				}
			} else {
				gf := NewGogenField(FieldName(GetSel(param.Type)), param.Type)
				gm.Params = append(gm.Params, gf)
				gsb.checkDefaultValue(gf)

			}

		}
	}

	if methodType.Results.NumFields() > 0 {
		for _, result := range methodType.Results.List {

			for _, s := range gsb.extractAllExpression(result.Type) {
				importFromMap, exist := gsb.importMap[s]
				if exist {
					gsb.usedImport[s] = importFromMap
				}
			}

			if result.Names != nil {
				for _, n := range result.Names {
					gf := NewGogenField(FieldName(n.String()), result.Type)
					gm.Results = append(gm.Results, gf)
					gsb.checkDefaultValue(gf)
				}
			} else {
				gf := NewGogenField(FieldName(GetSel(result.Type)), result.Type)
				gm.Results = append(gm.Results, gf)
				gsb.checkDefaultValue(gf)

			}

		}
	}
}

//func (gsb *GogenInterfaceBuilder) traceType__(path string, interfaceName FieldType, gc *GogenInterface) error {
//
//	if gsb.counter > 10 {
//		return nil
//	}
//
//	gsb.counter++
//
//	logDebug("kita akan parsing path %v untuk mencari interface target bernama %v", path, interfaceName)
//	fset := token.NewFileSet()
//	pkgs, err := parser.ParseDir(fset, path, nil, parser.ParseComments)
//	if err != nil {
//		return err
//	}
//
//	done := false
//
//	for _, pkg := range pkgs {
//
//		for _, file := range pkg.Files {
//
//			ast.Inspect(file, func(node ast.Node) bool {
//
//				// ignore the rest if error or done
//				if err != nil || done {
//					logDebug("dipaksa keluar karena %v", err.Error())
//					return false
//				}
//
//				// handle import
//				genDecl, ok := node.(*ast.GenDecl)
//				if ok && genDecl.Tok == token.IMPORT {
//					gsb.handleImport(genDecl)
//					return true
//				}
//
//				// focus to type
//				typeSpec, ok := node.(*ast.TypeSpec)
//				if !ok {
//					return true
//				}
//
//				// get type name
//				typeSpecName := typeSpec.Name.String()
//				logDebug("bertemu type %s, yg kita cari %v", typeSpecName, interfaceName)
//
//				if typeSpecName != string(interfaceName) {
//
//					logDebug("karena type %s != %s maka kita simpan dalam typeMap", typeSpecName, interfaceName)
//					gsb.typeMap[FieldType(typeSpecName)] = typeSpec.Type
//
//					return false
//				}
//
//				switch ts := typeSpec.Type.(type) {
//				case *ast.InterfaceType:
//					logDebug("bertemu interface target %s !! langsung kita olah MethodInterfacenya", interfaceName)
//					logDebug("start  handleMethodInterface")
//					err = gsb.handleMethodInterface(FieldType(typeSpecName), ts, gc)
//					if err != nil {
//						return false
//					}
//					logDebug("finish handleMethodInterface")
//
//				case *ast.StructType:
//					logDebug("target adalah struct")
//				}
//
//				return true
//			})
//
//		}
//
//	}
//
//	logDebug("sekarang kita selesaikan unknownInterface")
//
//	//for ut, gf := range gsb.unknownTypes {
//	//
//	//	logDebug("UNKNOWN %v %v", ut, gf)
//	//
//	//	switch expressionType := gf.DataType.Expr.(type) {
//	//	case *ast.SelectorExpr:
//	//
//	//		theEx := Expression(expressionType.X.(*ast.Ident).String())
//	//		gi, exist := gsb.importMap[theEx]
//	//		if !exist {
//	//			return fmt.Errorf("%s is not exist in importmap", theEx)
//	//		}
//	//
//	//		logDebug("dibaca sebagai selector %v", gi)
//	//
//	//		err = gsb.traceType(string(gi.CompletePath), gf.DataType.Type, gc)
//	//		if err != nil {
//	//			return err
//	//		}
//	//
//	//		//case *ast.Ident:
//	//		//	//gf.handleDefaultValue(ts)
//	//		//	//delete(gsb.unknownTypes, ut)
//	//	}
//	//
//	//}
//	//
//	//for k, _ := range gsb.typeMap {
//	//	logDebug(">>>> typemap %v", k)
//	//}
//	//
//	//logDebug("---------------")
//
//	return nil
//}
